#!/usr/bin/python3
import sys
import json
from collections import OrderedDict

def convert_color_single(color):
	if type(color) == str:
		color = config["colors"][color]

	ret = color[0] + color[1] * 256 + color[2] * 65536
	if len(color) > 3:
		ret += color[3] * 16777216
	else:
		ret += 4278190080

	return ret

def convert_colorset(color):
	if type(color) == list:
		return "{%s, %s}" % (convert_color_single(color[0]), convert_color_single(color[1]))
	else:
		ret = convert_color_single(color)
		return "{%s, %s}" % (ret, ret)

def convert_align(value):
	return "GLUI_ALIGN_" + value.upper().replace(" ", "_").replace("BOTTOM", "BOT")

def parse_base(source, name):
	element = {}

	element["type"] = "dummy"

	if "name" in source:
		element["name"] = source["name"]
	else:
		element["name"] = name

	if "draw" in source:
		element[".base.draw"] = source["draw"]

	if "x" in source:
		element[".base.x"] = source["x"]

	if "y" in source:
		element[".base.y"] = source["y"]

	if "width" in source:
		element[".base.width"] = source["width"]

	if "height" in source:
		element[".base.height"] = source["height"]

	if "align" in source:
		element[".base.align"] = convert_align(source["align"])

	if "disabled" in source:
		element[".base.disabled"] = int(source["disabled"])

	if "custom" in source:
		element[".base.custom"] = int(source["custom"])

	if "background" in source:
		element[".base.color"] = convert_colorset(source["background"])

	if "click" in source:
		element[".base.click"] = source["click"]
		ui_inputs.append("int32_t %s(glui_element_t*,int32_t,int32_t);\n" % source["click"])

	if "border" in source:
		if type(source["border"]) == OrderedDict:
			element[".base.border_size"] = source["border"]["size"]
			element[".base.border_color"] = convert_colorset(source["border"]["color"])
		else:
			element[".base.border_size"] = 1
			element[".base.border_color"] = convert_colorset(source["border"])

	return element

def parse_container(element, source, name):
	elist = []

	if "elements" in source:
		if type(source["elements"]) == int:
			elist = ["NULL"] * source["elements"]
		else:
			for idx, entry in enumerate(source["elements"]):
				if type(entry) == OrderedDict:
					enew = parse_element(entry, name + "_%03X" % idx)
					ui_elements.append(enew)
					elist.append("(void*)&" + enew["name"])
				else:
					elist.append("NULL")

	if "input" in source:
		element[".input"] = source["input"]
		ui_inputs.append("int32_t %s(glui_element_t*,uint32_t);\n" % source["input"])

	if "priority" in source:
		element[".priority"] = source["priority"]

	element["type"] = "container"
	element[".count"] = len(elist)
	element[".elements"] = elist

def parse_text(element, source):
	textinfo = {}

	element["type"] = "text"

	textinfo[".elm"] = "&%s" % element["name"]

	if "text" in source and type(source["text"]) == str:
		textinfo[".text"] = "\"%s\"" % source["text"].replace("\n", "\\n").replace("\"", "\\\"")

	if "font" in source:
		textinfo[".font"] = "glui_font_%s_kfn" % source["font"]

	if "text align" in source:
		textinfo[".align"] = convert_align(source["text align"])

	if "color" in source:
		element[".color"] = convert_colorset(source["color"])

	ui_text.append(textinfo)

def parse_image(element, source):
	imginfo = {}

	element["type"] = "image"

	if type(source["image"]) == str:
		element[".gltex"] = source["image"]

	if "shader" in source:
		element[".shader"] = "SHADER_FRAGMENT_%s" % source["shader"].replace(" ", "_").upper()

	if "coords" in source:
		element[".coord.s[0]"] = source["coords"][0]
		element[".coord.t[0]"] = source["coords"][1]
		element[".coord.s[1]"] = source["coords"][2]
		element[".coord.t[1]"] = source["coords"][3]
	else:
		element[".coord.s[0]"] = 0
		element[".coord.t[0]"] = 0
		element[".coord.s[1]"] = 1
		element[".coord.t[1]"] = 1

def parse_element(source, name):
	element = parse_base(source, name)
	if "elements" in source or "priority" in source:
		parse_container(element, source, name)
	elif "text" in source or "font" in source:
		parse_text(element, source)
	elif "image" in source:
		parse_image(element, source)
	return element

# reset
ui_elements = []
ui_fonts = []
ui_text = []
ui_inputs = []

# args
if len(sys.argv) < 3:
	print("usage:", sys.argv[0], "file.json base_name")
	exit(1)

# open and parse
with open(sys.argv[1], "rb") as f:
	data = json.loads(f.read().decode('utf8'), object_pairs_hook=OrderedDict)

# extract config
if "_glui_config" in data:
	config = data["_glui_config"]
	ui_fonts = config["fonts"]
	del data["_glui_config"]
else:
	config = {}

# parse elemens
for ui_name in data:
	ui_elements.append(parse_element(data[ui_name], ui_name))

# export H file
with open(sys.argv[2] + ".h", "w") as f:
	f.write("// THIS IS AUTOGENERATED FILE\n")

	if len(ui_text) > 0:
		f.write("#define GLUI_INIT_TEXT\t%u\n" % len(ui_text))

	for element in ui_inputs:
		f.write(element)

	for element in ui_fonts:
		f.write("extern uint8_t glui_font_%s_kfn[];\n" % element)

	for element in ui_elements:
		f.write("extern glui_%s_t %s;\n" % (element["type"], element["name"]))

# export C file
with open(sys.argv[2] + ".c", "w") as f:
	f.write("// THIS IS AUTOGENERATED FILE\n#include \"inc.h\"\n#include \"glui.h\"\n#include \"ui_def.h\"\n")

	if "includes" in config:
		for element in config["includes"]:
			f.write("#include \"%s\"\n" % element)

	for element in ui_elements:
		f.write("\nglui_%s_t %s =\n{\n" % (element["type"], element["name"]))

		if not ".base.draw" in element:
			f.write("\t.base.draw = glui_df_%s,\n" % element["type"])

		for entry in element:
			if entry[0] == ".":
				f.write("\t%s =" % entry)
				if type(element[entry]) == list:
					f.write("\n\t{\n")
					for value in element[entry]:
						f.write("\t\t%s,\n" % value)
					f.write("\t},\n")
				else:
					f.write(" %s,\n" % str(element[entry]))

		f.write("};\n")

	if len(ui_text) > 0:
		f.write("\nconst glui_init_text_t glui_init_text[GLUI_INIT_TEXT] =\n{\n")

		for element in ui_text:
			f.write("\t{\n")
			for entry in element:
				f.write("\t\t%s = %s,\n" % (entry, element[entry]))
			f.write("\t},\n")

		f.write("};\n")

